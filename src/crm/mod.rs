//! Clock configuration.
//!
//! This module provides functionality to configure the CRM to generate the requested clocks.
//!
//! # Example
//!
//! ```
//! let dp = pac::Peripherals::take().unwrap();
//! let crm = dp.CRM.constrain();
//! let clocks = crm
//!     .cfgr
//!     .use_hse(8.MHz())
//!     .sysclk(168.MHz())
//!     .pclk1(24.MHz())
//!     .i2s_clk(86.MHz())
//!     .require_pll48clk()
//!     .freeze();
//!     // Test that the I2S clock is suitable for 48000kHz audio.
//!     assert!(clocks.i2s_clk().unwrap() == 48.MHz().into());
//! ```
//!
//! # Limitations
//!
//! Unlike the clock configuration tool provided by ST, the code does not extensively search all
//! possible configurations. Instead, it often relies on an iterative approach to reduce
//! computational complexity. On most MCUs the code will first generate a configuration for the 48
//! MHz clock and the system clock without taking other requested clocks into account, even if the
//! accuracy of these clocks is affected. **If you specific accuracy requirements, you should
//! always check the resulting frequencies!**
//!
//! Whereas the hardware often supports flexible clock source selection and many clocks can be
//! sourced from multiple PLLs, the code implements a fixed mapping between PLLs and clocks. The 48
//! MHz clock is always generated by the main PLL, the I2S clocks are always generated by the I2S
//! PLL (unless a matching external clock input is provided), and similarly the SAI clocks are
//! always generated by the SAI PLL. It is therefore not possible to, for example, specify two
//! different I2S frequencies unless you also provide a matching I2S_CKIN signal for one of them.
//!
//! Some MCUs have limited clock generation hardware and do not provide either I2S or SAI PLLs even
//! though I2S or SAI are available. On the STM32F410, the I2S clock is generated by the main PLL,
//! and on the STM32F413/423 SAI clocks are generated by the I2S PLL. On these MCUs, the actual
//! frequencies may substantially deviate from the requested frequencies.

use crate::pac::{self, crm, CRM};

use fugit::HertzU32 as Hertz;

mod pll;

mod enable;
use crate::pac::crm::RegisterBlock as CrmRB;

/// Bus associated to peripheral
pub trait CrmBus: crate::Sealed {
    /// Bus type;
    type Bus;
}

/// Enable/disable peripheral
#[allow(clippy::missing_safety_doc)]
pub trait Enable: CrmBus {
    /// Enables peripheral
    fn enable(crm: &CrmRB);

    /// Disables peripheral
    fn disable(crm: &CrmRB);

    /// Check if peripheral enabled
    fn is_enabled() -> bool;

    /// Check if peripheral disabled
    #[inline]
    fn is_disabled() -> bool {
        !Self::is_enabled()
    }

    /// # Safety
    ///
    /// Enables peripheral. Takes access to CRM internally
    unsafe fn enable_unchecked() {
        let crm = &*pac::CRM::ptr();
        Self::enable(crm);
    }

    /// # Safety
    ///
    /// Disables peripheral. Takes access to CRM internally
    unsafe fn disable_unchecked() {
        let crm = pac::CRM::ptr();
        Self::disable(&*crm);
    }
}

/// Reset peripheral
#[allow(clippy::missing_safety_doc)]
pub trait Reset: CrmBus {
    /// Resets peripheral
    fn reset(crm: &CrmRB);

    /// # Safety
    ///
    /// Resets peripheral. Takes access to CRM internally
    unsafe fn reset_unchecked() {
        let crm = pac::CRM::ptr();
        Self::reset(&*crm);
    }
}

/// Extension trait that constrains the `CRM` peripheral
pub trait RccExt {
    /// Constrains the `CRM` peripheral so it plays nicely with the other abstractions
    fn constrain(self) -> Crm;
}

/// Frequency on bus that peripheral is connected in
pub trait BusClock {
    /// Calculates frequency depending on `Clock` state
    fn clock(clocks: &Clocks) -> Hertz;
}

/// Frequency on bus that timer is connected in
pub trait BusTimerClock {
    /// Calculates base frequency of timer depending on `Clock` state
    fn timer_clock(clocks: &Clocks) -> Hertz;
}

impl<T> BusClock for T
where
    T: CrmBus,
    T::Bus: BusClock,
{
    fn clock(clocks: &Clocks) -> Hertz {
        T::Bus::clock(clocks)
    }
}

impl<T> BusTimerClock for T
where
    T: CrmBus,
    T::Bus: BusTimerClock,
{
    fn timer_clock(clocks: &Clocks) -> Hertz {
        T::Bus::timer_clock(clocks)
    }
}

macro_rules! bus_struct {
    ($( $(#[$attr:meta])* $busX:ident => ($EN:ident, $en:ident, $RST:ident, $rst:ident, $doc:literal),)+) => {
        $(
            $(#[$attr])*
            #[doc = $doc]
            pub struct $busX {
                _0: (),
            }

            $(#[$attr])*
            impl $busX {
                pub(crate) fn enr(crm: &CrmRB) -> &crm::$EN {
                    &crm.$en
                }

                pub(crate) fn rstr(crm: &CrmRB) -> &crm::$RST {
                    &crm.$rst
                }
            }
        )+
    };
}

bus_struct! {
    APB1 => (APB1EN, apb1en, APB1RST, apb1rst, "Advanced Peripheral Bus 1 (APB1) registers"),
    APB2 => (APB2EN, apb2en, APB2RST, apb2rst, "Advanced Peripheral Bus 2 (APB2) registers"),
    AHB => (AHBEN, ahben, AHBRST, ahbrst, "Advanced High-performance Bus  (AHB) registers"),
}

impl BusClock for AHB {
    fn clock(clocks: &Clocks) -> Hertz {
        clocks.hclk
    }
}

impl BusClock for APB1 {
    fn clock(clocks: &Clocks) -> Hertz {
        clocks.pclk1
    }
}

impl BusClock for APB2 {
    fn clock(clocks: &Clocks) -> Hertz {
        clocks.pclk2
    }
}

impl BusTimerClock for APB1 {
    fn timer_clock(clocks: &Clocks) -> Hertz {
        clocks.timclk1
    }
}

impl BusTimerClock for APB2 {
    fn timer_clock(clocks: &Clocks) -> Hertz {
        clocks.timclk2
    }
}

impl RccExt for CRM {
    fn constrain(self) -> Crm {
        Crm {
            cfgr: CFGR {
                // hse: None,
                // hse_bypass: false,
                // hclk: None,
                // pclk1: None,
                // pclk2: None,
                // sysclk: None,
                // pll48clk: false,
                // i2s_ckin: None,
            },
        }
    }
}

/// Constrained CRM peripheral
pub struct Crm {
    pub cfgr: CFGR,
}

/// Built-in high speed clock frequency
pub const HSI: u32 = 16_000_000; // Hz

/// Minimum system clock frequency
pub const SYSCLK_MIN: u32 = 12_500_000;

/// Maximum system clock frequency
pub const SYSCLK_MAX: u32 = 168_000_000;

/// Maximum APB2 peripheral clock frequency
pub const PCLK2_MAX: u32 = SYSCLK_MAX;

/// Maximum APB1 peripheral clock frequency
pub const PCLK1_MAX: u32 = PCLK2_MAX / 2;

pub struct CFGR {
    // hse: Option<u32>,
    // hse_bypass: bool,
    // hclk: Option<u32>,
    // pclk1: Option<u32>,
    // pclk2: Option<u32>,
    // sysclk: Option<u32>,
    // pll48clk: bool,

    // i2s_ckin: Option<u32>,
}

#[cfg_attr(feature = "defmt", derive(defmt::Format))]
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
struct PllSetup {
    use_pll: bool,

    pllsysclk: Option<u32>,
    pll48clk: Option<u32>,
}

/// Frozen clock frequencies
///
/// The existence of this value indicates that the clock configuration can no longer be changed
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub struct Clocks {
    hclk: Hertz,
    pclk1: Hertz,
    pclk2: Hertz,
    timclk1: Hertz,
    timclk2: Hertz,
    sysclk: Hertz,
    pll48clk: Option<Hertz>,
}

impl Clocks {
    /// Returns the frequency of the AHB1
    pub fn hclk(&self) -> Hertz {
        self.hclk
    }

    /// Returns the frequency of the APB1
    pub fn pclk1(&self) -> Hertz {
        self.pclk1
    }

    /// Returns the frequency of the APB2
    pub fn pclk2(&self) -> Hertz {
        self.pclk2
    }

    /// Returns the frequency for timers on APB1
    pub fn timclk1(&self) -> Hertz {
        self.timclk1
    }

    /// Returns the frequency for timers on APB1
    pub fn timclk2(&self) -> Hertz {
        self.timclk2
    }

    /// Returns the system (core) frequency
    pub fn sysclk(&self) -> Hertz {
        self.sysclk
    }

    /// Returns the frequency of the PLL48 clock line
    pub fn pll48clk(&self) -> Option<Hertz> {
        self.pll48clk
    }

    /// Returns true if the PLL48 clock is within USB
    /// specifications. It is required to use the USB functionality.
    pub fn is_pll48clk_valid(&self) -> bool {
        // USB specification allows +-0.25%
        self.pll48clk
            .map(|freq| 48_000_000_u32.abs_diff(freq.raw()) <= 120_000)
            .unwrap_or_default()
    }
}
