//! Clock configuration.
//!
//! This module provides functionality to configure the CRM to generate the requested clocks.
//!
//! # Example
//!
//! ```
//! let dp = pac::Peripherals::take().unwrap();
//! let crm = dp.CRM.constrain();
//! let clocks = crm
//!     .cfgr
//!     .use_hext(8.MHz())
//!     .sysclk(168.MHz())
//!     .pclk1(24.MHz())
//!     .i2s_clk(86.MHz())
//!     .require_pll48clk()
//!     .freeze();
//!     // Test that the I2S clock is suitable for 48000kHz audio.
//!     assert!(clocks.i2s_clk().unwrap() == 48.MHz().into());
//! ```
//!
//! # Limitations
//!
//! Unlike the clock configuration tool provided by ST, the code does not extensively search all
//! possible configurations. Instead, it often relies on an iterative approach to reduce
//! computational complexity. On most MCUs the code will first generate a configuration for the 48
//! MHz clock and the system clock without taking other requested clocks into account, even if the
//! accuracy of these clocks is affected. **If you specific accuracy requirements, you should
//! always check the resulting frequencies!**
//!
//! Whereas the hardware often supports flexible clock source selection and many clocks can be
//! sourced from multiple PLLs, the code implements a fixed mapping between PLLs and clocks. The 48
//! MHz clock is always generated by the main PLL, the I2S clocks are always generated by the I2S
//! PLL (unless a matching external clock input is provided), and similarly the SAI clocks are
//! always generated by the SAI PLL. It is therefore not possible to, for example, specify two
//! different I2S frequencies unless you also provide a matching I2S_CKIN signal for one of them.
//!
//! Some MCUs have limited clock generation hardware and do not provide either I2S or SAI PLLs even
//! though I2S or SAI are available. On the STM32F410, the I2S clock is generated by the main PLL,
//! and on the STM32F413/423 SAI clocks are generated by the I2S PLL. On these MCUs, the actual
//! frequencies may substantially deviate from the requested frequencies.

use crate::pac::{self, crm, CRM};

use fugit::{HertzU32 as Hertz, RateExtU32};

use pll::MainPll;

mod pll;

mod enable;
use crate::pac::crm::RegisterBlock as CrmRB;

/// Bus associated to peripheral
pub trait CrmBus: crate::Sealed {
    /// Bus type;
    type Bus;
}

/// Enable/disable peripheral
#[allow(clippy::missing_safety_doc)]
pub trait Enable: CrmBus {
    /// Enables peripheral
    fn enable(crm: &CrmRB);

    /// Disables peripheral
    fn disable(crm: &CrmRB);

    /// Check if peripheral enabled
    fn is_enabled() -> bool;

    /// Check if peripheral disabled
    #[inline]
    fn is_disabled() -> bool {
        !Self::is_enabled()
    }

    /// # Safety
    ///
    /// Enables peripheral. Takes access to CRM internally
    unsafe fn enable_unchecked() {
        let crm = &*pac::CRM::ptr();
        Self::enable(crm);
    }

    /// # Safety
    ///
    /// Disables peripheral. Takes access to CRM internally
    unsafe fn disable_unchecked() {
        let crm = pac::CRM::ptr();
        Self::disable(&*crm);
    }
}

/// Reset peripheral
#[allow(clippy::missing_safety_doc)]
pub trait Reset: CrmBus {
    /// Resets peripheral
    fn reset(crm: &CrmRB);

    /// # Safety
    ///
    /// Resets peripheral. Takes access to CRM internally
    unsafe fn reset_unchecked() {
        let crm = pac::CRM::ptr();
        Self::reset(&*crm);
    }
}

/// Extension trait that constrains the `CRM` peripheral
pub trait CrmExt {
    /// Constrains the `CRM` peripheral so it plays nicely with the other abstractions
    fn constrain(self) -> Crm;
}

/// Frequency on bus that peripheral is connected in
pub trait BusClock {
    /// Calculates frequency depending on `Clock` state
    fn clock(clocks: &Clocks) -> Hertz;
}

/// Frequency on bus that timer is connected in
pub trait BusTimerClock {
    /// Calculates base frequency of timer depending on `Clock` state
    fn timer_clock(clocks: &Clocks) -> Hertz;
}

impl<T> BusClock for T
where
    T: CrmBus,
    T::Bus: BusClock,
{
    fn clock(clocks: &Clocks) -> Hertz {
        T::Bus::clock(clocks)
    }
}

impl<T> BusTimerClock for T
where
    T: CrmBus,
    T::Bus: BusTimerClock,
{
    fn timer_clock(clocks: &Clocks) -> Hertz {
        T::Bus::timer_clock(clocks)
    }
}

macro_rules! bus_struct {
    ($( $(#[$attr:meta])* $busX:ident => ($EN:ident, $en:ident, $RST:ident, $rst:ident, $doc:literal),)+) => {
        $(
            $(#[$attr])*
            #[doc = $doc]
            pub struct $busX {
                _0: (),
            }

            $(#[$attr])*
            impl $busX {
                pub(crate) fn enr(crm: &CrmRB) -> &crm::$EN {
                    &crm.$en
                }

                pub(crate) fn rstr(crm: &CrmRB) -> &crm::$RST {
                    &crm.$rst
                }
            }
        )+
    };
}

bus_struct! {
    APB1 => (APB1EN, apb1en, APB1RST, apb1rst, "Advanced Peripheral Bus 1 (APB1) registers"),
    APB2 => (APB2EN, apb2en, APB2RST, apb2rst, "Advanced Peripheral Bus 2 (APB2) registers"),
    AHB => (AHBEN, ahben, AHBRST, ahbrst, "Advanced High-performance Bus  (AHB) registers"),
}

impl BusClock for AHB {
    fn clock(clocks: &Clocks) -> Hertz {
        clocks.hclk
    }
}

impl BusClock for APB1 {
    fn clock(clocks: &Clocks) -> Hertz {
        clocks.pclk1
    }
}

impl BusClock for APB2 {
    fn clock(clocks: &Clocks) -> Hertz {
        clocks.pclk2
    }
}

impl BusTimerClock for APB1 {
    fn timer_clock(clocks: &Clocks) -> Hertz {
        clocks.tmr1clk
    }
}

impl BusTimerClock for APB2 {
    fn timer_clock(clocks: &Clocks) -> Hertz {
        clocks.tmr2clk
    }
}

impl CrmExt for CRM {
    fn constrain(self) -> Crm {
        Crm {
            cfgr: CFGR {
                hext: None,
                hext_bypass: false,
                hclk: None,
                pclk1: None,
                pclk2: None,
                sclk: None,
                pll48clk: false,
            },
        }
    }
}

/// Constrained CRM peripheral
pub struct Crm {
    pub cfgr: CFGR,
}

/// Built-in high speed clock frequency
pub const HICK: u32 = 48_000_000; // Hz

/// Minimum system clock frequency
pub const SYSCLK_MIN: u32 = 4_000_000;

/// Maximum system clock frequency
pub const SYSCLK_MAX: u32 = 150_000_000;

/// Maximum APB2 peripheral clock frequency
pub const PCLK2_MAX: u32 = SYSCLK_MAX / 2;

/// Maximum APB1 peripheral clock frequency
pub const PCLK1_MAX: u32 = SYSCLK_MAX / 2;

pub struct CFGR {
    hext: Option<u32>,
    hext_bypass: bool,
    hclk: Option<u32>,
    pclk1: Option<u32>,
    pclk2: Option<u32>,
    sclk: Option<u32>,
    pll48clk: bool,
}

impl CFGR {
    /// Uses HEXT (external oscillator) instead of HICK (internal RC oscillator) as the clock source.
    /// Will result in a hang if an external oscillator is not connected or it fails to start.
    pub fn use_hext(mut self, freq: Hertz) -> Self {
        self.hext = Some(freq.raw());
        self
    }

    pub fn hclk(mut self, freq: Hertz) -> Self {
        self.hclk = Some(freq.raw());
        self
    }

    pub fn pclk1(mut self, freq: Hertz) -> Self {
        self.pclk1 = Some(freq.raw());
        self
    }

    pub fn pclk2(mut self, freq: Hertz) -> Self {
        self.pclk2 = Some(freq.raw());
        self
    }

    pub fn sclk(mut self, freq: Hertz) -> Self {
        self.sclk = Some(freq.raw());
        self
    }

    pub fn require_pll48clk(mut self) -> Self {
        self.pll48clk = true;
        self
    }

    /// Initialises the hardware according to CFGR state returning a Clocks instance.
    /// Panics if overclocking is attempted.
    pub fn freeze(self) -> Clocks {
        self.freeze_internal(false)
    }

    /// Initialises the hardware according to CFGR state returning a Clocks instance.
    /// Allows overclocking.
    ///
    /// # Safety
    ///
    /// This method does not check if the clocks are bigger or smaller than the officially
    /// recommended.
    pub unsafe fn freeze_unchecked(self) -> Clocks {
        self.freeze_internal(true)
    }

    #[inline(always)]
    fn pll_setup(&self, pllsrcclk: u32, pllsysclk: Option<u32>) -> PllSetup {
        let main_pll = MainPll::fast_setup(
            pllsrcclk,
            self.hext.is_some(),
            Some(false),
            pllsysclk,
            self.pll48clk,
        );
        PllSetup {
            use_pll: main_pll.use_pll,
            pllsysclk: main_pll.pllsclk,
            pll48clk: main_pll.pll48clk,
        }
    }

    fn freeze_internal(self, unchecked: bool) -> Clocks {
        let crm = unsafe { &*CRM::ptr() };

        let pllsrcclk = self.hext.unwrap_or(HICK);
        let sclk = self.sclk.unwrap_or(pllsrcclk);
        let sclk_on_pll = sclk != pllsrcclk;

        let plls = self.pll_setup(pllsrcclk, sclk_on_pll.then_some(sclk));

        let clocks = Clocks {
            sclk: sclk.Hz(),
            hclk: 1.Hz(),
            pclk1: 1.Hz(),
            pclk2: 1.Hz(),
            tmr1clk: 1.Hz(),
            tmr2clk: 1.Hz(),
            usb48m: Some(1.Hz()),
        };
        clocks
    }
}

#[cfg_attr(feature = "defmt", derive(defmt::Format))]
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
struct PllSetup {
    use_pll: bool,
    pllsysclk: Option<u32>,
    pll48clk: Option<u32>,
}

/// Frozen clock frequencies
///
/// The existence of this value indicates that the clock configuration can no longer be changed
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub struct Clocks {
    sclk: Hertz,
    hclk: Hertz,
    pclk1: Hertz,
    pclk2: Hertz,
    tmr1clk: Hertz,
    tmr2clk: Hertz,
    usb48m: Option<Hertz>,
}

impl Clocks {
    /// Returns the frequency of the AHB1
    pub fn hclk(&self) -> Hertz {
        self.hclk
    }

    /// Returns the frequency of the APB1
    pub fn pclk1(&self) -> Hertz {
        self.pclk1
    }

    /// Returns the frequency of the APB2
    pub fn pclk2(&self) -> Hertz {
        self.pclk2
    }

    /// Returns the frequency for timers on APB1
    pub fn tmr1clk(&self) -> Hertz {
        self.tmr1clk
    }

    /// Returns the frequency for timers on APB1
    pub fn tmr2clk(&self) -> Hertz {
        self.tmr2clk
    }

    /// Returns the system (core) frequency
    pub fn sclk(&self) -> Hertz {
        self.sclk
    }

    /// Returns the frequency of the PLL48 clock line
    pub fn usb48m(&self) -> Option<Hertz> {
        self.usb48m
    }

    /// Returns true if the PLL48 clock is within USB
    /// specifications. It is required to use the USB functionality.
    pub fn is_usb48m_valid(&self) -> bool {
        // USB specification allows +-0.25%
        self.usb48m
            .map(|freq| 48_000_000_u32.abs_diff(freq.raw()) <= 120_000)
            .unwrap_or_default()
    }
}
