//! Clock configuration.
//!
//! This module provides functionality to configure the CRM to generate the requested clocks.
//!
//! # Example
//!
//! ```
//! let dp = pac::Peripherals::take().unwrap();
//! let crm = dp.CRM.constrain();
//! let clocks = crm
//!     .cfgr
//!     .use_hext(8.MHz())
//!     .sysclk(168.MHz())
//!     .pclk1(24.MHz())
//!     .require_pll48clk()
//!     .freeze();
//!     // Test that the I2S clock is suitable for 48000kHz audio.
//!     assert!(clocks.i2s_clk().unwrap() == 48.MHz().into());
//! ```
//!
//! # Limitations
//!
//! Unlike the clock configuration tool provided by ST, the code does not extensively search all
//! possible configurations. Instead, it often relies on an iterative approach to reduce
//! computational complexity. On most MCUs the code will first generate a configuration for the 48
//! MHz clock and the system clock without taking other requested clocks into account, even if the
//! accuracy of these clocks is affected. **If you specific accuracy requirements, you should
//! always check the resulting frequencies!**
//!
//! Whereas the hardware often supports flexible clock source selection and many clocks can be
//! sourced from multiple PLLs, the code implements a fixed mapping between PLLs and clocks. The 48
//! MHz clock is always generated by the main PLL, the I2S clocks are always generated by the I2S
//! PLL (unless a matching external clock input is provided), and similarly the SAI clocks are
//! always generated by the SAI PLL. It is therefore not possible to, for example, specify two
//! different I2S frequencies unless you also provide a matching I2S_CKIN signal for one of them.
//!
//! Some MCUs have limited clock generation hardware and do not provide either I2S or SAI PLLs even
//! though I2S or SAI are available. On the STM32F410, the I2S clock is generated by the main PLL,
//! and on the STM32F413/423 SAI clocks are generated by the I2S PLL. On these MCUs, the actual
//! frequencies may substantially deviate from the requested frequencies.

use crate::flash;
use crate::pac::crm::cfg::SCLKSEL_A;
use crate::pac::{self, crm, CRM};

use at32f4xx_pac::at32f415::crm::cfg::AHBDIV_A;
use fugit::{HertzU32 as Hertz, RateExtU32};

use pll::MainPll;

mod pll;

mod enable;
use crate::pac::crm::RegisterBlock as CrmRB;

/// Bus associated to peripheral
pub trait CrmBus: crate::Sealed {
    /// Bus type;
    type Bus;
}

/// Enable/disable peripheral
#[allow(clippy::missing_safety_doc)]
pub trait Enable: CrmBus {
    /// Enables peripheral
    fn enable(crm: &CrmRB);

    /// Disables peripheral
    fn disable(crm: &CrmRB);

    /// Check if peripheral enabled
    fn is_enabled() -> bool;

    /// Check if peripheral disabled
    #[inline]
    fn is_disabled() -> bool {
        !Self::is_enabled()
    }

    /// # Safety
    ///
    /// Enables peripheral. Takes access to CRM internally
    unsafe fn enable_unchecked() {
        let crm = &*pac::CRM::ptr();
        Self::enable(crm);
    }

    /// # Safety
    ///
    /// Disables peripheral. Takes access to CRM internally
    unsafe fn disable_unchecked() {
        let crm = pac::CRM::ptr();
        Self::disable(&*crm);
    }
}

/// Reset peripheral
#[allow(clippy::missing_safety_doc)]
pub trait Reset: CrmBus {
    /// Resets peripheral
    fn reset(crm: &CrmRB);

    /// # Safety
    ///
    /// Resets peripheral. Takes access to CRM internally
    unsafe fn reset_unchecked() {
        let crm = pac::CRM::ptr();
        Self::reset(&*crm);
    }
}

/// Extension trait that constrains the `CRM` peripheral
pub trait CrmExt {
    /// Constrains the `CRM` peripheral so it plays nicely with the other abstractions
    fn constrain(self) -> Crm;
}

/// Frequency on bus that peripheral is connected in
pub trait BusClock {
    /// Calculates frequency depending on `Clock` state
    fn clock(clocks: &Clocks) -> Hertz;
}

/// Frequency on bus that timer is connected in
pub trait BusTimerClock {
    /// Calculates base frequency of timer depending on `Clock` state
    fn timer_clock(clocks: &Clocks) -> Hertz;
}

impl<T> BusClock for T
where
    T: CrmBus,
    T::Bus: BusClock,
{
    fn clock(clocks: &Clocks) -> Hertz {
        T::Bus::clock(clocks)
    }
}

impl<T> BusTimerClock for T
where
    T: CrmBus,
    T::Bus: BusTimerClock,
{
    fn timer_clock(clocks: &Clocks) -> Hertz {
        T::Bus::timer_clock(clocks)
    }
}

macro_rules! bus_struct {
    ($( $(#[$attr:meta])* $busX:ident => ($EN:ident, $en:ident, $RST:ident, $rst:ident, $doc:literal),)+) => {
        $(
            $(#[$attr])*
            #[doc = $doc]
            pub struct $busX {
                _0: (),
            }

            $(#[$attr])*
            impl $busX {
                pub(crate) fn enr(crm: &CrmRB) -> &crm::$EN {
                    &crm.$en
                }

                pub(crate) fn rstr(crm: &CrmRB) -> &crm::$RST {
                    &crm.$rst
                }
            }
        )+
    };
}

bus_struct! {
    APB1 => (APB1EN, apb1en, APB1RST, apb1rst, "Advanced Peripheral Bus 1 (APB1) registers"),
    APB2 => (APB2EN, apb2en, APB2RST, apb2rst, "Advanced Peripheral Bus 2 (APB2) registers"),
    AHB => (AHBEN, ahben, AHBRST, ahbrst, "Advanced High-performance Bus  (AHB) registers"),
}

impl BusClock for AHB {
    fn clock(clocks: &Clocks) -> Hertz {
        clocks.hclk
    }
}

impl BusClock for APB1 {
    fn clock(clocks: &Clocks) -> Hertz {
        clocks.pclk1
    }
}

impl BusClock for APB2 {
    fn clock(clocks: &Clocks) -> Hertz {
        clocks.pclk2
    }
}

impl BusTimerClock for APB1 {
    fn timer_clock(clocks: &Clocks) -> Hertz {
        clocks.tmr1clk
    }
}

impl BusTimerClock for APB2 {
    fn timer_clock(clocks: &Clocks) -> Hertz {
        clocks.tmr2clk
    }
}

impl CrmExt for CRM {
    fn constrain(self) -> Crm {
        Crm {
            cfgr: CFGR {
                hext: None,
                hext_bypass: false,
                hclk: None,
                pclk1: None,
                pclk2: None,
                sclk: None,
                pll48clk: false,
            },
        }
    }
}

/// Constrained CRM peripheral
pub struct Crm {
    pub cfgr: CFGR,
}

/// Built-in high speed clock frequency
pub const HICK: u32 = 48_000_000; // Hz

/// Minimum system clock frequency
pub const SYSCLK_MIN: u32 = 4_000_000;

/// Maximum system clock frequency
pub const SYSCLK_MAX: u32 = 150_000_000;

/// Maximum APB2 peripheral clock frequency
pub const PCLK2_MAX: u32 = SYSCLK_MAX / 2;

/// Maximum APB1 peripheral clock frequency
pub const PCLK1_MAX: u32 = SYSCLK_MAX / 2;

pub struct CFGR {
    hext: Option<u32>,
    hext_bypass: bool,
    hclk: Option<u32>,
    pclk1: Option<u32>,
    pclk2: Option<u32>,
    sclk: Option<u32>,
    pll48clk: bool,
}

impl CFGR {
    /// Uses HEXT (external oscillator) instead of HICK (internal RC oscillator) as the clock source.
    /// Will result in a hang if an external oscillator is not connected or it fails to start.
    pub fn use_hext(mut self, freq: Hertz) -> Self {
        self.hext = Some(freq.raw());
        self
    }

    pub fn hclk(mut self, freq: Hertz) -> Self {
        self.hclk = Some(freq.raw());
        self
    }

    pub fn pclk1(mut self, freq: Hertz) -> Self {
        self.pclk1 = Some(freq.raw());
        self
    }

    pub fn pclk2(mut self, freq: Hertz) -> Self {
        self.pclk2 = Some(freq.raw());
        self
    }

    pub fn sclk(mut self, freq: Hertz) -> Self {
        self.sclk = Some(freq.raw());
        self
    }

    pub fn require_pll48clk(mut self) -> Self {
        self.pll48clk = true;
        self
    }

    fn flash_setup(sclk: u32) {
        use crate::pac::FLASH;

        let flash_latency_step = 32_000_000;

        unsafe {
            let flash = &(*FLASH::ptr());
            flash.psr.modify(|_, w| {
                w.pft_en().set_bit();
                w.wtcyc().bits(((sclk - 1) / flash_latency_step) as u8)
            });
        }
    }

    /// Initialises the hardware according to CFGR state returning a Clocks instance.
    /// Panics if overclocking is attempted.
    pub fn freeze(self) -> Clocks {
        self.freeze_internal(false)
    }

    /// Initialises the hardware according to CFGR state returning a Clocks instance.
    /// Allows overclocking.
    ///
    /// # Safety
    ///
    /// This method does not check if the clocks are bigger or smaller than the officially
    /// recommended.
    pub unsafe fn freeze_unchecked(self) -> Clocks {
        self.freeze_internal(true)
    }

    #[inline(always)]
    fn pll_setup(&self, pllsrcclk: u32, pllsysclk: Option<u32>) -> PllSetup {
        let main_pll = MainPll::fast_setup(
            pllsrcclk,
            self.hext.is_some(),
            Some(false),
            pllsysclk,
            self.pll48clk,
        );
        PllSetup {
            use_pll: main_pll.use_pll,
            pllsysclk: main_pll.pllsclk,
            pll48clk: main_pll.pll48clk,
        }
    }

    fn freeze_internal(self, unchecked: bool) -> Clocks {
        let crm = unsafe { &*CRM::ptr() };

        let sclk = self.sclk.unwrap_or(self.hext.unwrap_or(HICK));
        let sclk_on_pll = if self.hext.is_some() {
            sclk != self.hext.unwrap()
        } else {
            sclk != HICK && sclk != HICK / 6
        };
        let pllsrcclk = self.hext.unwrap_or(HICK / 12);

        let plls = self.pll_setup(pllsrcclk, sclk_on_pll.then_some(sclk));
        let sclk = if sclk_on_pll {
            plls.pllsysclk.unwrap()
        } else {
            sclk
        };

        let hclk = self.hclk.unwrap_or(sclk);
        let (ahbdiv_bits, ahbdiv) = match (sclk + hclk - 1) / hclk {
            1 => (AHBDIV_A::Sclk, 1),
            2 => (AHBDIV_A::Div2, 2),
            3..=5 => (AHBDIV_A::Div4, 4),
            6..=11 => (AHBDIV_A::Div8, 8),
            12..=39 => (AHBDIV_A::Div16, 16),
            40..=95 => (AHBDIV_A::Div64, 64),
            96..=191 => (AHBDIV_A::Div128, 128),
            192..=383 => (AHBDIV_A::Div256, 256),
            384..=767 => (AHBDIV_A::Div512, 512),
            _ => unreachable!(),
        };

        // Calculate real AHB clock
        let hclk = sclk / ahbdiv;

        let pclk1 = self
            .pclk1
            .unwrap_or_else(|| core::cmp::min(PCLK1_MAX, hclk));
        let (ppre1_bits, ppre1) = match (hclk + pclk1 - 1) / pclk1 {
            1 => (0b000, 1u8),
            2 => (0b100, 2),
            3..=5 => (0b101, 4),
            6..=11 => (0b110, 8),
            12..=24 => (0b111, 16),
            _ => unreachable!(),
        };

        // Calculate real APB1 clock
        let pclk1 = hclk / u32::from(ppre1);

        assert!(unchecked || pclk1 <= PCLK1_MAX);

        let pclk2 = self
            .pclk2
            .unwrap_or_else(|| core::cmp::min(PCLK2_MAX, hclk));
        let (ppre2_bits, ppre2) = match (hclk + pclk2 - 1) / pclk2 {
            1 => (0b000, 1u8),
            2 => (0b100, 2),
            3..=5 => (0b101, 4),
            6..=11 => (0b110, 8),
            12..=24 => (0b111, 16),
            _ => unreachable!(),
        };

        // Calculate real APB2 clock
        let pclk2 = hclk / u32::from(ppre1);

        assert!(unchecked || pclk2 <= PCLK2_MAX);

        Self::flash_setup(sclk);

        if self.hext.is_some() {
            // enable HEXT and wait for it to be ready
            crm.ctrl.modify(|_, w| {
                if self.hext_bypass {
                    w.hextbyps().set_bit();
                }
                w.hexten().set_bit()
            });
            while crm.ctrl.read().hextstbl().bit_is_clear() {}
        }

        if plls.use_pll {
            // Enable PLL
            crm.ctrl.modify(|_, w| w.pllen().set_bit());

            // Wait for PLL to stabilise
            while crm.ctrl.read().pllstbl().bit_is_clear() {}
        }

        crm.cfg
            .modify(|_, w| unsafe { w.ahbdiv().variant(ahbdiv_bits) });

        // Wait for the new prescalers to kick in
        // "The clocks are divided with the new prescaler factor from 1 to 16 AHB cycles after write"
        cortex_m::asm::delay(16);

        crm.cfg.modify(|_, w| {
            w.sclksel().variant(if sclk_on_pll {
                SCLKSEL_A::Pll
            } else if self.hext.is_some() {
                SCLKSEL_A::Hext
            } else {
                SCLKSEL_A::Hick
            })
        });

        let pclk_mul = if ppre1 == 1 { 1 } else { 2 };
        let tmr1clk = Hertz::from_raw(pclk1 * pclk_mul);

        let pclk_mul = if ppre2 == 1 { 1 } else { 2 };
        let tmr2clk = Hertz::from_raw(pclk2 * pclk_mul);

        let clocks = Clocks {
            sclk: sclk.Hz(),
            hclk: hclk.Hz(),
            pclk1: pclk1.Hz(),
            pclk2: pclk2.Hz(),
            tmr1clk,
            tmr2clk,
            usb48m: Some(48_000_000.Hz()),
        };

        if self.pll48clk {
            assert!(clocks.is_usb48m_valid());
        }

        clocks
    }
}

#[cfg_attr(feature = "defmt", derive(defmt::Format))]
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
struct PllSetup {
    use_pll: bool,
    pllsysclk: Option<u32>,
    pll48clk: Option<u32>,
}

/// Frozen clock frequencies
///
/// The existence of this value indicates that the clock configuration can no longer be changed
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub struct Clocks {
    sclk: Hertz,
    hclk: Hertz,
    pclk1: Hertz,
    pclk2: Hertz,
    tmr1clk: Hertz,
    tmr2clk: Hertz,
    usb48m: Option<Hertz>,
}

impl Clocks {
    /// Returns the frequency of the AHB1
    pub fn hclk(&self) -> Hertz {
        self.hclk
    }

    /// Returns the frequency of the APB1
    pub fn pclk1(&self) -> Hertz {
        self.pclk1
    }

    /// Returns the frequency of the APB2
    pub fn pclk2(&self) -> Hertz {
        self.pclk2
    }

    /// Returns the frequency for timers on APB1
    pub fn tmr1clk(&self) -> Hertz {
        self.tmr1clk
    }

    /// Returns the frequency for timers on APB1
    pub fn tmr2clk(&self) -> Hertz {
        self.tmr2clk
    }

    /// Returns the system (core) frequency
    pub fn sclk(&self) -> Hertz {
        self.sclk
    }

    /// Returns the frequency of the PLL48 clock line
    pub fn usb48m(&self) -> Option<Hertz> {
        self.usb48m
    }

    /// Returns true if the PLL48 clock is within USB
    /// specifications. It is required to use the USB functionality.
    pub fn is_usb48m_valid(&self) -> bool {
        // USB specification allows +-0.25%
        self.usb48m
            .map(|freq| 48_000_000_u32.abs_diff(freq.raw()) <= 120_000)
            .unwrap_or_default()
    }
}
